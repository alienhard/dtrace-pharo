'From Squeak4.3 of 22 December 2011 [latest update: #11860] on 20 April 2012 at 10:19:42 am'!!CCodeGenerator methodsFor: 'C code generator' stamp: 'pad 4/19/2012 23:16'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: VMMaker headerNotice.	aStream nextPutAll: ' */'; cr.	self emitGlobalStructFlagOn: aStream.	aStream nextPutAll: '#include "sq.h"'; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	"Default definitions for optional functions, provided for backward compatibility"	self emitDefaultMacrosOn: aStream.	aStream nextPutAll: '#include "sqMemoryAccess.h"//DTrace#include "squeak_provider.h"sqInt printCallStack(void);void defaultErrorProc(char *s) {	/* Print an error message and exit. */	static sqInt printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.! !!Interpreter methodsFor: 'message sending' stamp: 'pad 4/19/2012 23:20'!internalExecuteNewMethod	| localPrimIndex delta nArgs |	<inline: true>	localPrimIndex := primitiveIndex.	localPrimIndex > 0		ifTrue: [(localPrimIndex > 255					and: [localPrimIndex < 520])				ifTrue: ["Internal return instvars"					localPrimIndex >= 264						ifTrue: [^ self internalPop: 1 thenPush: (objectMemory fetchPointer: localPrimIndex - 264 ofObject: self internalStackTop)]						ifFalse: ["Internal return constants"							localPrimIndex = 256 ifTrue: [^ nil].							localPrimIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: objectMemory trueObj].							localPrimIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: objectMemory falseObj].							localPrimIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: objectMemory nilObj].							^ self internalPop: 1 thenPush: (objectMemory integerObjectOf: localPrimIndex - 261)]]				ifFalse: [self externalizeIPandSP.					"self primitiveResponse. <-replaced with  manually inlined code"					DoBalanceChecks						ifTrue: ["check stack balance"							nArgs := argumentCount.							delta := stackPointer - activeContext].					"DTrace"					self logMethodenter: localPrimIndex..																	self initPrimCall.					self dispatchFunctionPointer: primitiveFunctionPointer. "branch direct to prim function from address stored in mcache"					DoBalanceChecks						ifTrue: [(self balancedStack: delta afterPrimitive: localPrimIndex withArgs: nArgs)								ifFalse: [self printUnbalancedStack: localPrimIndex]].					self internalizeIPandSP.										"DTrace -- primitive call is done"					self logMethodreturnFrom: lkupClass selector: messageSelector.															self successful						ifTrue: [self browserPluginReturnIfNeeded.							^ nil]]].	"DTrace -- entering method; if successFlag=false, method was called b/c prim failed"	self logMethodenter: localPrimIndex.									"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts! !!Interpreter methodsFor: 'process primitive support' stamp: 'pad 4/19/2012 23:30'!transferTo: aProc 	"Record a process to be awoken on the next interpreter cycle. 	ikp 11/24/1999 06:07 -- added hook for external runtime 	compiler "	| sched oldProc newProc newPid oldPid pOld pNew |	newProc := aProc.	sched := self schedulerPointer.	oldProc := objectMemory fetchPointer: ActiveProcessIndex ofObject: sched.	objectMemory storePointer: ActiveProcessIndex ofObject: sched withValue: newProc.	compilerInitialized		ifTrue: [self compilerProcessChange: oldProc to: newProc]		ifFalse: [objectMemory storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.			self newActiveContext: (objectMemory fetchPointer: SuspendedContextIndex ofObject: newProc).			objectMemory storePointer: SuspendedContextIndex ofObject: newProc withValue: objectMemory nilObj].	reclaimableContextCount := 0.		"DTrace"	self cCode: 'if (SQUEAK_PROC_TRANSFERTO_ENABLED()) {'.	oldPid := self hashBitsOf: oldProc.	newPid := self hashBitsOf: newProc.	pOld := self quickFetchInteger: PriorityIndex ofObject: oldProc.	pNew := self quickFetchInteger: PriorityIndex ofObject: newProc.	self cCode: 'SQUEAK_PROC_TRANSFERTO(oldPid, pOld, newPid, pNew);	}'! !!Interpreter methodsFor: 'return bytecodes' stamp: 'pad 4/19/2012 23:23'!commonReturn	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller localCntx localVal unwindMarked  home methClass methodSel |	<inline: true>	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop := objectMemory nilObj. "keep in a register"	thisCntx := activeContext.	localCntx := localReturnContext.	localVal := localReturnValue.	"make sure we can return to the given context"	((localCntx = nilOop) or:	 [(objectMemory fetchPointer: InstructionPointerIndex ofObject: localCntx) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		^self internalCannotReturn: localVal].	"If this return is not to our immediate predecessor (i.e. from a method to its sender, or from a block to its caller), scan the stack for the first unwind marked context and inform this context and let it deal with it. This provides a chance for ensure unwinding to occur."	thisCntx := objectMemory fetchPointer: SenderIndex ofObject: activeContext.	"Just possibly a faster test would be to compare the homeContext and activeContext - they are of course different for blocks. Thus we might be able to optimise a touch by having a different returnTo for the blockreteurn (since we know that must return to caller) and then if active ~= home we must be doing a non-local return. I think. Maybe."	[thisCntx = localCntx] whileFalse: [		thisCntx = nilOop ifTrue:[			"error: sender's instruction pointer or context is nil; cannot return"			^self internalCannotReturn: localVal].		"Climb up stack towards localCntx. Break out to a send of #aboutToReturn:through: if an unwind marked context is found"		unwindMarked := self isUnwindMarked: thisCntx.		unwindMarked ifTrue:[			"context is marked; break out"			^self internalAboutToReturn: localVal through: thisCntx].		thisCntx := objectMemory fetchPointer: SenderIndex ofObject: thisCntx. ].	"If we get here there is no unwind to worry about. Simply terminate the stack up to the localCntx - often just the sender of the method"	thisCntx := activeContext.	[thisCntx = localCntx]		whileFalse:		["climb up stack to localCntx"		contextOfCaller := objectMemory fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		objectMemory storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		objectMemory storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue:			["try to recycle this context"			reclaimableContextCount := reclaimableContextCount - 1.			objectMemory recycleContextIfPossible: thisCntx].		thisCntx := contextOfCaller].	"DTrace"	self cCode: 'if (SQUEAK_METHODRETURN_ENABLED()) {'.		(self fetchClassOf: thisCntx) = (self splObj: ClassBlockContext)			ifTrue: [ home := self fetchPointer: HomeIndex ofObject: thisCntx ]			ifFalse: [ home := thisCntx ].		methClass := self			findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)			forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel := self			findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)			forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self logMethodreturnFrom: methClass selector: methodSel.	self cCode: '}'.	activeContext := thisCntx.	(objectMemory oop: thisCntx isLessThan: objectMemory youngStart) ifTrue: [ objectMemory beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: localVal.! !!Interpreter methodsFor: 'object memory support' stamp: 'pad 4/19/2012 23:38'!postGCAction: fullGCFlag	"Mark the active and home contexts as roots if old. This 	allows the interpreter to use storePointerUnchecked to 	store into them."	fullGCFlag		ifTrue: [ self cCode: 'SQUEAK_GCEND()' ]		ifFalse: [ self cCode: 'SQUEAK_IGCEND()' ].			compilerInitialized		ifTrue: [self compilerPostGC]		ifFalse: [(objectMemory oop: activeContext isLessThan: objectMemory youngStart)				ifTrue: [objectMemory beRootIfOld: activeContext].			(objectMemory oop: theHomeContext isLessThan: objectMemory youngStart)				ifTrue: [objectMemory beRootIfOld: theHomeContext]].	(objectMemory oop: (objectMemory sizeOfFree: objectMemory freeBlock) isGreaterThan:  objectMemory shrinkThreshold)		ifTrue: ["Attempt to shrink memory after successfully 			reclaiming lots of memory"			objectMemory shrinkObjectMemory: (objectMemory sizeOfFree: objectMemory freeBlock) - objectMemory growHeadroom].		self signalSemaphoreWithIndex: objectMemory gcSemaphoreIndex.! !!Interpreter methodsFor: 'object memory support' stamp: 'al 5/22/2009 15:43'!preGCAction: fullGCFlag	fullGCFlag		ifTrue: [ self cCode: 'SQUEAK_GCBEGIN()' ]		ifFalse: [ self cCode: 'SQUEAK_IGCBEGIN()' ].	compilerInitialized		ifTrue: [self compilerPreGC: fullGCFlag]		ifFalse: [self storeContextRegisters: activeContext].! !!Interpreter methodsFor: 'debug dtrace' stamp: 'pad 4/20/2012 06:53'!logMethodenter: primitiveMethodIndex	"Not inlining is critical concerning performance!! If inlined, the foo->lkupClass and foo->messageSelector, even if never called, have a significant negative effect on performance. Not sure what GCC (using 4.2.1) is doing there..."	<inline: false>		self cCode: '		if (SQUEAK_METHODENTER_ENABLED()) {			void *classname = (char*)nameOfClasscount(foo->lkupClass, 5);			void *selector = (char*)stringOfOop(foo->messageSelector);			SQUEAK_METHODENTER(classname, selector, primitiveMethodIndex, foo->primFailCode);			free(classname);			free(selector); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/4/2010 13:58'!logMethodreturnFrom: methClass selector: methodSel	self cCode: 'if (SQUEAK_METHODRETURN_ENABLED()) {'.	self cCode:'				void *classname = (char*)nameOfClasscount(methClass, 5);			void *selector = (char*)stringOfOop(methodSel);			SQUEAK_METHODRETURN(classname, selector, foo->primitiveIndex);			free(classname);			free(selector); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/4/2010 14:19'!logObjectAllocationOf: classPointer withSize: byteSize	self cCode: '		if (SQUEAK_OBJECTALLOC_ENABLED()) {			void *classname = (char*)nameOfClasscount(classPointer, 5);			SQUEAK_OBJECTALLOC(classname, byteSize);			free(classname); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'pad 4/20/2012 00:11'!nameOfClass: classOop count: cnt	self export: true.	self returnTypeC: 'char*'.	self cCode: '	if (cnt <= 0) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	if ((sizeBitsOf(classOop)) == (7 * BYTES_PER_WORD)) {		char* name = nameOfClasscount(longAt((classOop + BASE_HEADER_SIZE) + (5 <<  SHIFT_FOR_WORD)), cnt - 1);		char* result = (char*) malloc((strlen(name) + strlen(" class") + 1) * sizeof(char));  		strcpy(result, name);		strcat(result, " class");		free(name);		return result;	} else {		return stringOfOop(longAt((classOop + BASE_HEADER_SIZE) + (6 <<  SHIFT_FOR_WORD)));	}	'! !!Interpreter methodsFor: 'debug dtrace' stamp: 'pad 4/20/2012 00:12'!stringOfOop: oop	self export: true.	self returnTypeC: 'char*'.	self cCode: '        sqInt fmt;    sqInt cnt;    sqInt i;	if ((oop & 1)) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;	if (fmt < 8) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	cnt = ((100 < (lengthOf(oop))) ? 100 : (lengthOf(oop)));	i = 0;		char *buf;	buf = (char*) malloc((cnt+1) * sizeof(char)); 		while (i < cnt) {		/* begin printChar: */		buf[i] = (byteAt((oop + BASE_HEADER_SIZE) + i));		i += 1;	}	buf[i] = ''\0'';	return buf'! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'pad 4/19/2012 23:37'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	<inline: false>	<var: #startTime type: 'sqLong'>	DoAssertionChecks ifTrue: [interpreter reverseDisplayFrom: 0 to: 7].	interpreter preGCAction: true.	startTime := interpreter ioMicroSecondClock.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self clearRootsTable.	youngStart := self startOfMemory.  "process all of memory"	self markPhase.	"Sweep phase returns the number of survivors.	Use the up-to-date version instead the one from startup."	totalObjectCount := self sweepPhase.	self fullCompaction.	allocationCount := 0.	statFullGCs := statFullGCs + 1.	statGCTime := interpreter ioMicroSecondClock.	statFullGCMSecs := statFullGCMSecs + (statGCTime - startTime).	interpreter capturePendingFinalizationSignals.	youngStart := freeBlock.  "reset the young object boundary"	interpreter postGCAction:true.	DoAssertionChecks ifTrue: [interpreter reverseDisplayFrom: 0 to: 7].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'dtl 2/19/2012 09:05'!incrementalGC	"Do a mark/sweep garbage collection of just the young object 	area of object memory (i.e., objects above youngStart), using 	the root table to identify objects containing pointers to 	young objects from the old object area."	| survivorCount startTime weDidGrow |	<inline: false>	<var: #startTime type: 'sqLong'>	rootTableCount >= RootTableSize		ifTrue: ["root table overflow; cannot do an incremental GC (this should be very rare)"			statRootTableOverflows := statRootTableOverflows + 1.			^ self fullGC].	DoAssertionChecks		ifTrue: [interpreter reverseDisplayFrom: 8 to: 15.			self validateRoots; validate].	interpreter preGCAction: false.	"incremental GC and compaction"	startTime := interpreter ioMicroSecondClock.	weakRootCount := 0.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self markPhase.	1 to: weakRootCount do:[:i| self finalizeReference: (weakRoots at: i)].	survivorCount := self sweepPhase.	self incrementalCompaction.	statAllocationCount := allocationCount.	allocationCount := 0.	statIncrGCs := statIncrGCs + 1.	statGCTime := interpreter ioMicroSecondClock.	statIGCDeltaTime := statGCTime - startTime.	statIncrGCMSecs := statIncrGCMSecs + statIGCDeltaTime.	interpreter capturePendingFinalizationSignals.	interpreter forceInterruptCheck. "Force an an interrupt check ASAP.We could choose to be clever here and only do this under certain time conditions. Keep it simple for now"		statRootTableCount  := rootTableCount.	statSurvivorCount := survivorCount.	weDidGrow := false.	(((survivorCount > tenuringThreshold)			or: [rootTableCount >= RootTableRedZone])			or: [forceTenureFlag == true])		ifTrue: ["move up the young space boundary if 			* there are too many survivors: 			this limits the number of objects that must be 			processed on future incremental GC's 			* we're about to overflow the roots table 			this limits the number of full GCs that may be caused 			by root table overflows in the near future"			forceTenureFlag := false.			statTenures := statTenures + 1.			self clearRootsTable.			(freeBlock < growHeadroom and: 				[gcBiasToGrow > 0]) 				ifTrue: [self biasToGrow.						weDidGrow := true].			youngStart := freeBlock].	interpreter postGCAction.	DoAssertionChecks		ifTrue: [self validateRoots; validate.			interpreter reverseDisplayFrom: 8 to: 15].	weDidGrow ifTrue: [self biasToGrowCheckGCLimit]! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'pad 4/19/2012 23:14'!instantiateClass: classPointer indexableSize: size 	"NOTE: This method supports the backward-compatible split instSize field of the 	class format word. The sizeHiBits will go away and other shifts change by 2 	when the split fields get merged in an (incompatible) image change."	| hash header1 header2 cClass byteSize format binc header3 hdrSize fillWord newObj sizeHiBits bm1 classFormat |	<inline: false>	DoAssertionChecks ifTrue: [size < 0				ifTrue: [self error: 'cannot have a negative indexable field count']].	hash := self newObjectHash.	classFormat := self formatOfClass: classPointer.	"Low 2 bits are 0"	header1 := (classFormat bitAnd: 16r1FF00) bitOr: (hash << HashBitsOffset bitAnd: HashBits).	header2 := classPointer.	header3 := 0.	sizeHiBits := (classFormat bitAnd: 16r60000) >> 9.	cClass := header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize := (classFormat bitAnd: self sizeMask + self size4Bit) + sizeHiBits.		"size in bytes -- low 2 bits are 0"	"Note this byteSize comes from the format word of the class which is pre-shifted		to 4 bytes per field.  Need another shift for 8 bytes per word..."	byteSize := byteSize << (self shiftForWord - 2).	format := classFormat >> 8 bitAnd: 15.	self flag: #sizeLowBits.	format < 8		ifTrue:			[format = 6				ifTrue: ["long32 bitmaps"					bm1 := self bytesPerWord - 1.					byteSize := byteSize + (size * 4) + bm1 bitAnd: self longSizeMask. "round up"					binc := bm1 - ((size * 4) + bm1 bitAnd: bm1). "odd bytes"					"extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits)"					header1 := header1 bitOr: (binc bitAnd: 4)]				ifFalse: [byteSize := byteSize + (size * self bytesPerWord) "Arrays and 64-bit bitmaps"]			]		ifFalse:			["Strings and Methods"			bm1 := self bytesPerWord - 1.			byteSize := byteSize + size + bm1 bitAnd: self longSizeMask. "round up"			binc := bm1 - (size + bm1 bitAnd: bm1). "odd bytes"			"low bits of byte size go in format field"			header1 := header1 bitOr: (binc bitAnd: 3) << 8.			"extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits)"			header1 := header1 bitOr: (binc bitAnd: 4)].	byteSize > 255		ifTrue: ["requires size header word"			header3 := byteSize.			header1 := header1]		ifFalse: [header1 := header1 bitOr: byteSize].	header3 > 0		ifTrue: ["requires full header"			hdrSize := 3]		ifFalse: [cClass = 0				ifTrue: [hdrSize := 2]				ifFalse: [hdrSize := 1]].	format <= 4		ifTrue: ["if pointers, fill with nil oop"			fillWord := nilObj]		ifFalse: [fillWord := 0].	newObj := self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 doFill: true with: fillWord.	interpreter logObjectAllocationOf: classPointer withSize: byteSize.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'pad 4/19/2012 23:14'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes	"This version of instantiateClass assumes that the total object 	size is under 256 bytes, the limit for objects with only one or 	two header words. Note that the size is specified in bytes 	and should include 4 or 8 bytes for the base header word. 	NOTE this code will only work for sizes that are an integral number of words		(like not a 32-bit LargeInteger in a 64-bit system). 	May cause a GC.	Note that the created small object IS NOT FILLED and must be completed before returning it to Squeak. Since this call is used in routines that do jsut that we are safe. Break this rule and die."	| hash header1 header2 hdrSize |	(sizeInBytes bitAnd: (self bytesPerWord - 1)) = 0 ifFalse:		[self error: 'size must be integral number of words'].	hash := self newObjectHash.	header1 := (hash << HashBitsOffset bitAnd: HashBits) bitOr: (self formatOfClass: classPointer).	header2 := classPointer.	(header1 bitAnd: CompactClassMask) > 0 "is this a compact class"		ifTrue: [hdrSize := 1]		ifFalse: [hdrSize := 2].	header1 := header1 + (sizeInBytes - (header1 bitAnd: self sizeMask + self size4Bit)).	interpreter logObjectAllocationOf: classPointer withSize: sizeInBytes.	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: false with: 0! !