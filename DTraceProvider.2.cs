'From PharoCore1.0 of 19 October 2009 [Latest update: #10517] on 9 May 2010 at 9:14:18 pm'!!CCodeGenerator methodsFor: 'C code generator' stamp: 'al 3/10/2010 20:50'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* '.	aStream nextPutAll: VMMaker headerNotice.	aStream nextPutAll: ' */'; cr; cr.	self emitGlobalStructFlagOn: aStream.	aStream nextPutAll: '#include "sq.h"'; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	aStream nextPutAll: '#include "sqMemoryAccess.h"//DTrace#include "squeak_provider.h"sqInt printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static sqInt printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'al 5/22/2009 15:45'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	self inline: false.	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].	self preGCAction: true.	startTime := self ioMicroMSecs.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self clearRootsTable.	youngStart := self startOfMemory.  "process all of memory"	self markPhase.	"Sweep phase returns the number of survivors.	Use the up-to-date version instead the one from startup."	totalObjectCount := self sweepPhase.	self fullCompaction.	allocationCount := 0.	statFullGCs := statFullGCs + 1.	statGCTime := self ioMicroMSecs.	statFullGCMSecs := statFullGCMSecs + (statGCTime - startTime).	self capturePendingFinalizationSignals.	youngStart := freeBlock.  "reset the young object boundary"	self postGCAction: true.	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'al 3/10/2010 20:35'!incrementalGC	"Do a mark/sweep garbage collection of just the young object 	area of object memory (i.e., objects above youngStart), using 	the root table to identify objects containing pointers to 	young objects from the old object area."	| survivorCount startTime weDidGrow |	self inline: false.	rootTableCount >= RootTableSize		ifTrue: ["root table overflow; cannot do an incremental GC (this should be very rare)"			statRootTableOverflows := statRootTableOverflows + 1.			^ self fullGC].	DoAssertionChecks		ifTrue: [self reverseDisplayFrom: 8 to: 15.			self validateRoots; validate].	self preGCAction: false.	"incremental GC and compaction"	startTime := self ioMicroMSecs.	weakRootCount := 0.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self markPhase.	1 to: weakRootCount do:[:i| self finalizeReference: (weakRoots at: i)].	survivorCount := self sweepPhase.	self incrementalCompaction.	statAllocationCount := allocationCount.	allocationCount := 0.	statIncrGCs := statIncrGCs + 1.	statGCTime := self ioMicroMSecs.	statIGCDeltaTime := statGCTime - startTime.	statIncrGCMSecs := statIncrGCMSecs + statIGCDeltaTime.	self capturePendingFinalizationSignals.	self forceInterruptCheck. "Force an an interrupt check ASAP.We could choose to be clever here and only do this under certain time conditions. Keep it simple for now"		statRootTableCount  := rootTableCount.	statSurvivorCount := survivorCount.	weDidGrow := false.	(((survivorCount > tenuringThreshold)			or: [rootTableCount >= RootTableRedZone])			or: [forceTenureFlag == true])		ifTrue: ["move up the young space boundary if 			* there are too many survivors: 			this limits the number of objects that must be 			processed on future incremental GC's 			* we're about to overflow the roots table 			this limits the number of full GCs that may be caused 			by root table overflows in the near future"			forceTenureFlag := false.			statTenures := statTenures + 1.			self clearRootsTable.			(freeBlock < growHeadroom and: 				[gcBiasToGrow > 0]) 				ifTrue: [self biasToGrow.						weDidGrow := true].			youngStart := freeBlock].	self postGCAction: false.	DoAssertionChecks		ifTrue: [self validateRoots; validate.			self reverseDisplayFrom: 8 to: 15].	weDidGrow ifTrue: [self biasToGrowCheckGCLimit]! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'al 5/4/2010 13:53'!instantiateClass: classPointer indexableSize: size 	"NOTE: This method supports the backward-compatible split instSize field of the 	class format word. The sizeHiBits will go away and other shifts change by 2 	when the split fields get merged in an (incompatible) image change."	| hash header1 header2 cClass byteSize format binc header3 hdrSize fillWord newObj sizeHiBits bm1 classFormat |	self inline: false.	DoAssertionChecks ifTrue: [size < 0				ifTrue: [self error: 'cannot have a negative indexable field count']].	hash := self newObjectHash.	classFormat := self formatOfClass: classPointer.	"Low 2 bits are 0"	header1 := (classFormat bitAnd: 16r1FF00) bitOr: (hash << HashBitsOffset bitAnd: HashBits).	header2 := classPointer.	header3 := 0.	sizeHiBits := (classFormat bitAnd: 16r60000) >> 9.	cClass := header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize := (classFormat bitAnd: SizeMask + Size4Bit) + sizeHiBits.		"size in bytes -- low 2 bits are 0"	"Note this byteSize comes from the format word of the class which is pre-shifted		to 4 bytes per field.  Need another shift for 8 bytes per word..."	byteSize := byteSize << (ShiftForWord-2).	format := classFormat >> 8 bitAnd: 15.	self flag: #sizeLowBits.	format < 8		ifTrue:			[format = 6				ifTrue: ["long32 bitmaps"					bm1 := BytesPerWord-1.					byteSize := byteSize + (size * 4) + bm1 bitAnd: LongSizeMask. "round up"					binc := bm1 - ((size * 4) + bm1 bitAnd: bm1). "odd bytes"					"extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits)"					header1 := header1 bitOr: (binc bitAnd: 4)]				ifFalse: [byteSize := byteSize + (size * BytesPerWord) "Arrays and 64-bit bitmaps"]			]		ifFalse:			["Strings and Methods"			bm1 := BytesPerWord-1.			byteSize := byteSize + size + bm1 bitAnd: LongSizeMask. "round up"			binc := bm1 - (size + bm1 bitAnd: bm1). "odd bytes"			"low bits of byte size go in format field"			header1 := header1 bitOr: (binc bitAnd: 3) << 8.			"extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits)"			header1 := header1 bitOr: (binc bitAnd: 4)].	byteSize > 255		ifTrue: ["requires size header word"			header3 := byteSize.			header1 := header1]		ifFalse: [header1 := header1 bitOr: byteSize].	header3 > 0		ifTrue: ["requires full header"			hdrSize := 3]		ifFalse: [cClass = 0				ifTrue: [hdrSize := 2]				ifFalse: [hdrSize := 1]].	format <= 4		ifTrue: ["if pointers, fill with nil oop"			fillWord := nilObj]		ifFalse: [fillWord := 0].	newObj := self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 doFill: true with: fillWord.	self logObjectAllocationOf: classPointer withSize: byteSize.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'al 5/4/2010 13:55'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes	"This version of instantiateClass assumes that the total object 	size is under 256 bytes, the limit for objects with only one or 	two header words. Note that the size is specified in bytes 	and should include 4 or 8 bytes for the base header word. 	NOTE this code will only work for sizes that are an integral number of words		(like not a 32-bit LargeInteger in a 64-bit system). 	May cause a GC.	Note that the created small object IS NOT FILLED and must be completed before returning it to Squeak. Since this call is used in routines that do jsut that we are safe. Break this rule and die."	| hash header1 header2 hdrSize |	(sizeInBytes bitAnd: (BytesPerWord-1)) = 0 ifFalse:		[self error: 'size must be integral number of words'].	hash := self newObjectHash.	header1 := (hash << HashBitsOffset bitAnd: HashBits) bitOr: (self formatOfClass: classPointer).	header2 := classPointer.	(header1 bitAnd: CompactClassMask) > 0 "is this a compact class"		ifTrue: [hdrSize := 1]		ifFalse: [hdrSize := 2].	header1 := header1 + (sizeInBytes - (header1 bitAnd: SizeMask+Size4Bit)).	self logObjectAllocationOf: classPointer withSize: sizeInBytes.	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: false with: 0! !!Interpreter methodsFor: 'message sending' stamp: 'al 5/9/2010 15:20'!internalExecuteNewMethod	| localPrimIndex delta nArgs |	self inline: true.	localPrimIndex := primitiveIndex.	localPrimIndex > 0		ifTrue: [(localPrimIndex > 255					and: [localPrimIndex < 520])				ifTrue: ["Internal return instvars"					localPrimIndex >= 264						ifTrue: [^ self internalPop: 1 thenPush: (self fetchPointer: localPrimIndex - 264 ofObject: self internalStackTop)]						ifFalse: ["Internal return constants"							localPrimIndex = 256 ifTrue: [^ nil].							localPrimIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].							localPrimIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].							localPrimIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].							^ self internalPop: 1 thenPush: (self integerObjectOf: localPrimIndex - 261)]]				ifFalse: [							self externalizeIPandSP.					"self primitiveResponse. <-replaced with  manually inlined code"					DoBalanceChecks						ifTrue: ["check stack balance"							nArgs := argumentCount.							delta := stackPointer - activeContext].					successFlag := true.										"DTrace"					self logMethodenter: localPrimIndex..										self dispatchFunctionPointer: primitiveFunctionPointer. "branch direct to prim function from address stored in mcache"					DoBalanceChecks						ifTrue: [(self balancedStack: delta afterPrimitive: localPrimIndex withArgs: nArgs)								ifFalse: [self printUnbalancedStack: localPrimIndex]].					self internalizeIPandSP.					"DTrace -- primitive call is done"					self logMethodreturnFrom: lkupClass selector: messageSelector.					successFlag						ifTrue: [self browserPluginReturnIfNeeded.							^ nil]]].	"DTrace -- entering method; if successFlag=false, method was called b/c prim failed"		self logMethodenter: localPrimIndex.		"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.		! !!Interpreter methodsFor: 'return bytecodes' stamp: 'al 5/9/2010 17:08'!commonReturn	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller localCntx localVal unwindMarked home methClass methodSel |		self inline: true.		self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop := nilObj. "keep in a register"	thisCntx := activeContext.	localCntx := localReturnContext.	localVal := localReturnValue.	"make sure we can return to the given context"	((localCntx = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: localCntx) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		^self internalCannotReturn: localVal].	"If this return is not to our immediate predecessor (i.e. from a method to its sender, or from a block to its caller), scan the stack for the first unwind marked context and inform this context and let it deal with it. This provides a chance for ensure unwinding to occur."	thisCntx := self fetchPointer: SenderIndex ofObject: activeContext.	"Just possibly a faster test would be to compare the homeContext and activeContext - they are of course different for blocks. Thus we might be able to optimise a touch by having a different returnTo for the blockreteurn (since we know that must return to caller) and then if active ~= home we must be doing a non-local return. I think. Maybe."	[thisCntx = localCntx] whileFalse: [		thisCntx = nilOop ifTrue:[			"error: sender's instruction pointer or context is nil; cannot return"			^self internalCannotReturn: localVal].		"Climb up stack towards localCntx. Break out to a send of #aboutToReturn:through: if an unwind marked context is found"		unwindMarked := self isUnwindMarked: thisCntx.		unwindMarked ifTrue:[			"context is marked; break out"			^self internalAboutToReturn: localVal through: thisCntx].		thisCntx := self fetchPointer: SenderIndex ofObject: thisCntx. ].	"If we get here there is no unwind to worry about. Simply terminate the stack up to the localCntx - often just the sender of the method"	thisCntx := activeContext.	[thisCntx = localCntx]		whileFalse:		["climb up stack to localCntx"		contextOfCaller := self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue:			["try to recycle this context"			reclaimableContextCount := reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx].		thisCntx := contextOfCaller].		"DTrace"	self cCode: 'if (SQUEAK_METHODRETURN_ENABLED()) {'.		(self fetchClassOf: thisCntx) = (self splObj: ClassBlockContext)			ifTrue: [ home := self fetchPointer: HomeIndex ofObject: thisCntx ]			ifFalse: [ home := thisCntx ].		methClass := self			findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)			forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel := self			findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)			forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self logMethodreturnFrom: methClass selector: methodSel.	self cCode: '}'.		activeContext := thisCntx.	(self oop: thisCntx isLessThan: youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: localVal.! !!Interpreter methodsFor: 'object memory support' stamp: 'al 5/22/2009 15:47'!postGCAction: fullGCFlag	"Mark the active and home contexts as roots if old. This 	allows the interpreter to use storePointerUnchecked to 	store into them."	fullGCFlag		ifTrue: [ self cCode: 'SQUEAK_GCEND()' ]		ifFalse: [ self cCode: 'SQUEAK_IGCEND()' ].			compilerInitialized		ifTrue: [self compilerPostGC]		ifFalse: [(self oop: activeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: activeContext].			(self oop: theHomeContext isLessThan: youngStart)				ifTrue: [self beRootIfOld: theHomeContext]].	(self oop: (self sizeOfFree: freeBlock) isGreaterThan:  shrinkThreshold)		ifTrue: ["Attempt to shrink memory after successfully 			reclaiming lots of memory"			self shrinkObjectMemory: (self sizeOfFree: freeBlock) - growHeadroom].		self signalSemaphoreWithIndex: gcSemaphoreIndex.! !!Interpreter methodsFor: 'object memory support' stamp: 'al 5/22/2009 15:43'!preGCAction: fullGCFlag	fullGCFlag		ifTrue: [ self cCode: 'SQUEAK_GCBEGIN()' ]		ifFalse: [ self cCode: 'SQUEAK_IGCBEGIN()' ].	compilerInitialized		ifTrue: [self compilerPreGC: fullGCFlag]		ifFalse: [self storeContextRegisters: activeContext].! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/9/2010 19:24'!logMethodenter: primitiveMethodIndex	"Not inlining is critical concerning performance!! If inlined, the foo->lkupClass and foo->messageSelector, even if never called, have a significant negative effect on performance. Not sure what GCC (using 4.2.1) is doing there..."	self inline: false.		self cCode: '		if (SQUEAK_METHODENTER_ENABLED()) {			void *classname = (char*)nameOfClasscount(foo->lkupClass, 5);			void *selector = (char*)stringOfOop(foo->messageSelector);			SQUEAK_METHODENTER(classname, selector, primitiveMethodIndex, foo->successFlag);			free(classname);			free(selector); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/4/2010 13:58'!logMethodreturnFrom: methClass selector: methodSel	self cCode: 'if (SQUEAK_METHODRETURN_ENABLED()) {'.	self cCode:'				void *classname = (char*)nameOfClasscount(methClass, 5);			void *selector = (char*)stringOfOop(methodSel);			SQUEAK_METHODRETURN(classname, selector, foo->primitiveIndex);			free(classname);			free(selector); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/4/2010 14:19'!logObjectAllocationOf: classPointer withSize: byteSize	self cCode: '		if (SQUEAK_OBJECTALLOC_ENABLED()) {			void *classname = (char*)nameOfClasscount(classPointer, 5);			SQUEAK_OBJECTALLOC(classname, byteSize);			free(classname); }'.! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/8/2010 20:50'!nameOfClass: classOop count: cnt	self export: true.	self returnTypeC: 'char*'.	self cCode: '	if (cnt <= 0) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	if ((sizeBitsOf(classOop)) == (7 * BytesPerWord)) {		char* name = nameOfClasscount(longAt((classOop + BaseHeaderSize) + (5 << ShiftForWord)), cnt - 1);		char* result = (char*) malloc((strlen(name) + strlen(" class") + 1) * sizeof(char));  		strcpy(result, name);		strcat(result, " class");		free(name);		return result;	} else {		return stringOfOop(longAt((classOop + BaseHeaderSize) + (6 << ShiftForWord)));	}	'! !!Interpreter methodsFor: 'debug dtrace' stamp: 'al 5/8/2010 20:50'!stringOfOop: oop	self export: true.	self returnTypeC: 'char*'.	self cCode: '        sqInt fmt;    sqInt cnt;    sqInt i;	if ((oop & 1)) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;	if (fmt < 8) {		char* result = (char*) malloc(2*sizeof(char));		return strcpy(result, "?\0");	}	cnt = ((100 < (lengthOf(oop))) ? 100 : (lengthOf(oop)));	i = 0;		char *buf;	buf = (char*) malloc((cnt+1) * sizeof(char)); 		while (i < cnt) {		/* begin printChar: */		buf[i] = (byteAt((oop + BaseHeaderSize) + i));		i += 1;	}	buf[i] = ''\0'';	return buf'! !!Interpreter methodsFor: 'processes' stamp: 'al 5/3/2010 17:43'!transferTo: aProc 	"Record a process to be awoken on the next interpreter cycle. 	ikp 11/24/1999 06:07 -- added hook for external runtime 	compiler "	| sched oldProc newProc newPid oldPid pOld pNew |	newProc := aProc.	sched := self schedulerPointer.	oldProc := self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: ActiveProcessIndex ofObject: sched withValue: newProc.	compilerInitialized		ifTrue: [self compilerProcessChange: oldProc to: newProc]		ifFalse: [self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.			self newActiveContext: (self fetchPointer: SuspendedContextIndex ofObject: newProc).			self storePointer: SuspendedContextIndex ofObject: newProc withValue: nilObj].	reclaimableContextCount := 0.		"DTrace"	self cCode: 'if (SQUEAK_PROC_TRANSFERTO_ENABLED()) {'.	oldPid := self hashBitsOf: oldProc.	newPid := self hashBitsOf: newProc.	pOld := self quickFetchInteger: PriorityIndex ofObject: oldProc.	pNew := self quickFetchInteger: PriorityIndex ofObject: newProc.	self cCode: 'SQUEAK_PROC_TRANSFERTO(oldPid, pOld, newPid, pNew);	}'! !